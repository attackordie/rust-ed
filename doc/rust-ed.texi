\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename rust-ed.info
@documentencoding UTF-8
@settitle rust-ed Manual
@finalout
@c %**end of header

@set UPDATED 5 November 2025
@set VERSION 0.1.0

@dircategory Basics
@direntry
* rust-ed: (rust-ed).           Memory-safe replacement for GNU ed
@end direntry

@copying
Copyright @copyright{} 2025 Brian Boynton, MD

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@end copying

@ifnothtml
@titlepage
@title rust-ed
@subtitle Memory-safe line editor
@subtitle for rust-ed version @value{VERSION}, @value{UPDATED}
@author by Brian Boynton, MD

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents
@end ifnothtml

@ifnottex
@node Top
@top The rust-ed line editor

This manual is for rust-ed (version @value{VERSION}, @value{UPDATED}).

@menu
* Overview::                        Overview of the @command{rust-ed} command
* Introduction to line editing::    Getting started with @command{rust-ed}
* Invoking rust-ed::                Command-line interface
* Line addressing::                 Specifying lines/ranges in the buffer
* Regular expressions::             Patterns for selecting text
* Commands::                        Commands recognized by @command{rust-ed}
* The 's' Command::                 Substitute command
* Memory Safety::                   Safety advantages of Rust implementation
* Limitations::                     Intrinsic limits of @command{rust-ed}
* Diagnostics::                     @command{rust-ed} error handling
* Problems::                        Reporting bugs
* GNU Free Documentation License::  How you can copy and share this manual
@end menu

@sp 1
@noindent
Written by Brian Boynton, MD
@insertcopying
@end ifnottex


@node Overview
@chapter Overview

@command{rust-ed} is a memory-safe, 100% drop-in replacement for GNU ed 1.22.2
written in Rust. It is a line-oriented text editor used to create, display,
modify and otherwise manipulate text files, both interactively and via shell
scripts.

@command{rust-ed} provides the exact same functionality as GNU ed while
eliminating entire classes of memory safety vulnerabilities inherent in C
implementations. It prevents buffer overflows, use-after-free errors, null
pointer dereferences, and other memory-related bugs through Rust's ownership
system and borrow checker.

If invoked with a @var{file} argument, then a copy of @var{file} is read
into the editor's buffer. Changes are made to this copy and not directly to
@var{file} itself. Upon quitting @command{rust-ed}, any changes not explicitly
saved with a @samp{w} command are lost. In interactive mode, a non-existing
@var{file} is reported but does not alter the exit status.

Editing is done in two distinct modes: @dfn{command} and @dfn{input}. When
first invoked, @command{rust-ed} is in command mode. In this mode commands are
read from the standard input and executed to manipulate the contents of the
editor buffer. A typical command might look like:

@example
,s/@var{old}/@var{new}/g
@end example

which replaces all occurences of the string @var{old} with @var{new}.

When an input command, such as @samp{a} (append), @samp{i} (insert) or
@samp{c} (change), is given, @command{rust-ed} enters input mode. This is the
primary means of adding text to a file. In this mode, no commands are
available; instead, the standard input is written directly to the editor
buffer. A @dfn{line} consists of the text up to and including a
@key{newline} character. Input mode is terminated by entering a single
period (@samp{.}) on a line.

All @command{rust-ed} commands operate on whole lines or ranges of lines;
e.g., the @samp{d} command deletes lines; the @samp{m} command moves lines,
and so on. It is possible to modify only a portion of a line by means of
replacement, as in the example above. However even here, the @samp{s}
command is applied to whole lines at a time.

In general, @command{rust-ed} commands consist of zero or more line addresses,
followed by a single character command and possibly additional parameters;
i.e., commands have the structure:

@example
[@var{address}[,@var{address}]]@var{command}[@var{parameters}]
@end example

The @var{address}es indicate the line or range of lines to be affected by
the command. If fewer addresses are given than the command accepts, then
default addresses are supplied.


@node Introduction to line editing
@chapter Introduction to line editing

@command{rust-ed} maintains 100% compatibility with GNU ed 1.22.2, which
itself is based on the original Unix ed created by Ken Thompson and Dennis
Ritchie. It is the refinement of its more complex, programmable predecessor,
@cite{QED}, to which Thompson and Ritchie had already added pattern matching
capabilities (@pxref{Regular expressions}).

For the purposes of this tutorial, a working knowledge of the Unix shell
and the Unix file system is recommended, since @command{rust-ed} is designed
to interact closely with them.

The principal difference between line editors and display editors is that
display editors provide instant feedback to user commands, whereas line
editors require sometimes lengthy input before any effects are seen. The
advantage of instant feedback, of course, is that if a mistake is made, it
can be corrected immediately, before more damage is done. Editing in
@command{rust-ed} requires more strategy and forethought; but if you are
up to the task, it can be quite efficient.

Much of the @command{rust-ed} command syntax is shared with other Unix
utilities and is identical to GNU ed.

As with the shell, @key{RETURN} (the carriage-return key) enters a line
of input. So when we speak of "entering" a command or some text in
@command{rust-ed}, @key{RETURN} is implied at the end of each line.

When @command{rust-ed} first opens, it expects to be told what to do but
doesn't prompt us like the shell. So let's begin by telling @command{rust-ed}
to do so with the @key{P} (@dfn{prompt}) command:

@example
$ rust-ed
P
*
@end example

By default, @command{rust-ed} uses asterisk (@samp{*}) as command prompt to
avoid confusion with the shell command prompt (@samp{$}).

We can run Unix shell commands from inside @command{rust-ed} by prefixing
them with @key{!} (exclamation mark, aka "bang"). For example:

@example
*!date
Mon Nov  5 10:08:41 PST 2025
!
*!echo "Hello from Rust"
Hello from Rust
!
*
@end example

For detailed interactive examples and tutorials, @command{rust-ed} behaves
identically to GNU ed. Please refer to the GNU ed manual's "Introduction to
line editing" chapter for comprehensive examples.

Related programs or routines are @command{vi}(1), @command{sed}(1),
@command{regex}(3), @command{sh}(1). Relevant documents are:

@quotation
B. W. Kernighan and P. J. Plauger: "Software Tools in Pascal",
Addison-Wesley, 1981.
@end quotation


@node Invoking rust-ed
@chapter Invoking rust-ed

The format for running @command{rust-ed} is:

@example
rust-ed [@var{options}] [[+@var{line}] @var{file}]
rust-ed [@var{options}] [[+@var{line}] '!@var{command} [@var{arguments}]']
@end example

@var{file} specifies the name of a file to read. If @var{file} is prefixed
with a bang (!), then it is interpreted as a shell command. In this case,
what is read is the standard output of @var{file} executed via @command{sh}.
To read a file whose name begins with a bang (or a hyphen), prefix the name
with @file{./}. The default filename is set to @var{file} only if it is not
prefixed with a bang.

The file name may be preceded by @samp{+@var{line}} to set the current line
to the line number specified. If @var{line} exceeds the number of lines in
the file, the current line is set to the last line.

The file name may be preceded by @samp{+/@var{re}} to set the current line
to the first line matching the regular expression @var{re}, or by
@samp{+?@var{re}} to set the current line to the last line matching
@var{re}. If @var{re} does not match any line, rust-ed fails immediately with
exit status 1 unless the option @option{-l} is specified and standard input
is not a regular file.

@noindent
@command{rust-ed} supports the following options:

@table @code
@item -h
@itemx --help
Print an informative help message describing the options and exit.

@item -V
@itemx --version
Print the version number of @command{rust-ed} on the standard output and exit.
This version number should be included in all bug reports.

@item -E
@itemx --extended-regexp
Use extended regular expressions instead of the basic regular expressions
mandated by POSIX.

@item -G
@itemx --traditional
Forces backwards compatibility. This affects the behavior of the
@command{rust-ed} commands @samp{G}, @samp{V}, @samp{f}, @samp{l}, @samp{m},
@samp{t}, and @samp{!!}. If the default behavior of these commands does
not seem familiar, then try invoking @command{rust-ed} with this switch.

@item -l
@itemx --loose-exit-status
Don't exit with bad status if a command happens to "fail" (for example
if a substitution command finds nothing to replace). This can be useful
when @command{rust-ed} is invoked as the editor for crontab.

@item -p @var{string}
@itemx --prompt=@var{string}
Specifies a command prompt string and turns prompting on. Showing the prompt
string may be toggled on and off with the @samp{P} command.

@item -q
@itemx --quiet
@itemx --silent
Suppress diagnostic messages written to standard error.

@item -r
@itemx --restricted
Run in restricted mode. This mode disables editing of files out of the
current directory and execution of shell commands.

@item -s
@itemx --script
Suppress the printing of byte counts by @samp{e}, @samp{E}, @samp{r},
@samp{w}, and @samp{!} commands, and the @samp{!} prompt after a @samp{!}
command. Suppress also the messages "Newline inserted" and "Newline
appended". This option does not suppress diagnostic messages written to
standard error (see @option{-q} above). @option{-s} may be useful if
@command{rust-ed}'s standard input is from a script.

@item -v
@itemx --verbose
Turn help mode on; print a help message explaining the reason for each
@samp{?} notification. This may be toggled on and off with the @samp{H}
command. Use this option to aid in debugging ed scripts.

@item --strip-trailing-cr
Strip the carriage returns at the end of text lines in DOS files. CRs are
removed only from the CR/LF (carriage return/line feed) pair ending the
line. CRs at other positions in the line, including a CR finishing an
unterminated line, are not removed. The CRs are not restored when saving the
buffer to a file.

@item --unsafe-names
@command{rust-ed} rejects file names containing control characters unless they
are allowed with this option. Newline characters in file names are rejected
even if this option is specified.

@end table

Exit status: 0 for a normal exit, 1 for environmental problems
(invalid command-line options, memory exhausted, command failed, etc),
2 for problems with the input file (file not found, buffer modified,
I/O errors), 3 for an internal consistency error (e.g., bug) which caused
rust-ed to panic.


@node Line addressing
@chapter Line addressing

An address represents the number of a line in the buffer. @command{rust-ed}
maintains a @dfn{current address} which is typically supplied to commands as
the default address when none is specified. When a file is first read, the
current address is set to the address of the last line of the file. In
general, the current address is set to the address of the last line affected
by a command.

One exception to the rule that addresses represent line numbers is the
address @samp{0} (zero). This means "at the beginning of the buffer", and is
valid wherever it makes sense.

An address range is two addresses separated either by a comma (@samp{,}) or
a semicolon (@samp{;}). The value of the first address in a range cannot
exceed the value of the second.

In a semicolon-delimited range, the current address (@samp{.}) is set to the
first address before the second address is calculated. This feature can be
used to set the starting line for searches if the second address contains a
regular expression. The address @samp{0} (zero) is valid as a starting point
so that @samp{0;/@var{re}/} can match @var{re} in the first line of the buffer.

A line address is constructed as follows:

@table @code
@item .
The current line (address) in the buffer.

@item $
The last line in the buffer.

@item @var{n}
The @var{n}th line in the buffer, where @var{n} is a number in the range
@samp{0,$}.

@item +@var{n}
The @var{n}th next line, where @var{n} is a non-negative number.

@item -@var{n}
The @var{n}th previous line, where @var{n} is a non-negative number.

@item +
The next line. This is equivalent to @samp{+1} and may be repeated with
cumulative effect.

@item -
The previous line. This is equivalent to @samp{-1} and may be repeated with
cumulative effect.

@item ,
The first through last lines in the buffer. This is equivalent to the
address range @samp{1,$}.

@item ;
The current through last lines in the buffer. This is equivalent to the
address range @samp{.;$}.

@item /@var{re}/[I]
The next line containing the regular expression @var{re}. The search wraps
to the beginning of the buffer and continues down to the current line, if
necessary. The suffix @samp{I} makes @command{rust-ed} match @var{re} in a
case-insensitive manner.

@item ?@var{re}?[I]
The previous line containing the regular expression @var{re}. The search
wraps to the end of the buffer and continues up to the current line, if
necessary. The suffix @samp{I} makes @command{rust-ed} match @var{re} in a
case-insensitive manner.

@item 'x
The apostrophe-x character pair addresses the line previously marked by a
@samp{k} (mark) command, where @samp{x} is a lower case letter from the
portable character set @samp{[a-z]}.

@end table


@node Regular expressions
@chapter Regular expressions

Regular expressions in @command{rust-ed} use the Rust @code{regex} crate,
which implements POSIX-compatible regular expression syntax. The behavior is
identical to GNU ed with extended regular expressions enabled.

Regular expressions are patterns used in selecting text. For example, the
@command{rust-ed} command

@example
g/@var{string}/
@end example

@noindent
prints all lines containing @var{string}. Regular expressions are also used
by the @samp{s} command for selecting old text to be replaced with new text.

In addition to specifying string literals, regular expressions can represent
classes of strings. Strings thus represented are said to be matched by the
corresponding regular expression.

An empty regular expression is equivalent to the last regular expression
processed.

As a GNU extension (fully supported by @command{rust-ed}), a regular
expression /@var{re}/ may be followed by the suffix @samp{I} which makes
@command{rust-ed} match @var{re} in a case-insensitive manner.

For detailed regular expression syntax, @command{rust-ed} supports the same
patterns as GNU ed. Please refer to the GNU ed manual's "Regular expressions"
chapter for comprehensive syntax details.


@node Commands
@chapter Commands

All @command{rust-ed} commands are single characters, though some require
additional parameters. @command{rust-ed} implements all 32 commands from
GNU ed 1.22.2 with identical behavior.

@anchor{print suffixes}
In general, at most one command is allowed per line. However, most
commands accept a print suffix, which is any of @samp{p} (print),
@samp{l} (list), or @samp{n} (enumerate), to print the last line
affected by the command.

The following commands are supported (see GNU ed manual for detailed
descriptions of each command):

@table @code

@item (.)a
Append text after the addressed line.

@item (.,.)c
Change (replace) lines in the buffer.

@item (.,.)d
Delete the addressed lines from the buffer.

@item e @var{file}
Edit @var{file}, clearing the buffer first.

@item E @var{file}
Edit @var{file} unconditionally, discarding changes.

@item f @var{file}
Set or print the default filename.

@item (1,$)g/@var{re}/[I]@var{command-list}
Global command - apply commands to lines matching @var{re}.

@item (1,$)G/@var{re}/[I]
Interactive global command.

@item h
Print help message for last error.

@item H
Toggle help mode on and off.

@item (.)i
Insert text before the addressed line.

@item (.,.+1)j
Join the addressed lines.

@item (.)kx
Mark a line with letter @samp{x}.

@item (.,.)l
List lines unambiguously with special characters escaped.

@item (.,.)m(.)
Move lines to after the destination address.

@item (.,.)n
Number - print lines with line numbers.

@item (.,.)p
Print the addressed lines.

@item P
Toggle command prompt on and off.

@item q
Quit @command{rust-ed}.

@item Q
Quit unconditionally, discarding changes.

@item ($)r @var{file}
Read @var{file} and append after the addressed line.

@item (.,.)s/@var{re}/@var{replacement}/[@var{flags}]
Substitute text matching @var{re} with @var{replacement}.

@item (.,.)t(.)
Copy (transfer) lines to after the destination address.

@item u
Undo the last command that modified the buffer.

@item (1,$)v/@var{re}/[I]@var{command-list}
Apply commands to lines NOT matching @var{re}.

@item (1,$)V/@var{re}/[I]
Interactive command for lines NOT matching @var{re}.

@item (1,$)w @var{file}
Write addressed lines to @var{file}.

@item (1,$)wq @var{file}
Write and quit.

@item (1,$)W @var{file}
Append addressed lines to @var{file}.

@item (.)x
Put (paste) contents of cut buffer.

@item (.,.)y
Yank (copy) addressed lines to cut buffer.

@item (.+1)z@var{n}
Scroll - print @var{n} lines.

@item !@var{command}
@itemx [2addr]!@var{command}
Execute shell command.

@item (.,.)#
Comment line.

@item ($)=
Print line number.

@item (.+1)@key{newline}
Print next line.

@end table


@node The 's' Command
@chapter Substitute command

The substitute command @samp{s} in @command{rust-ed} behaves identically
to GNU ed. It replaces text in the addressed lines matching a regular
expression @var{re} with @var{replacement}.

The syntax is:

@example
(.,.)s/@var{re}/@var{replacement}/[@var{suffixes}]
@end example

Supported suffixes include:
@table @code
@item g
Replace all matches in the line.

@item @var{count}
Replace only the @var{count}th match.

@item l, n, p
Print suffixes.

@item I, i
Case-insensitive matching.
@end table

For detailed substitute command documentation, see the GNU ed manual's
"The 's' Command" chapter.


@node Memory Safety
@chapter Memory safety advantages

@command{rust-ed} provides significant memory safety advantages over C
implementations of ed:

@section Vulnerability classes prevented

@table @strong

@item Buffer overflows
Prevented by Rust's bounds-checked collections. All array and vector
accesses are verified at runtime, eliminating a major class of security
vulnerabilities.

@item Use-after-free
Prevented by Rust's ownership system. The borrow checker ensures that
references cannot outlive the data they point to.

@item Memory leaks
Prevented by RAII (Resource Acquisition Is Initialization) and automatic
Drop trait implementation. Memory is automatically freed when it goes out
of scope.

@item Null pointer dereferences
Prevented by Rust's Option<T> type system. There are no null pointers in
safe Rust - values that may not exist are explicitly wrapped in Option.

@item Integer overflows
Prevented by explicit overflow checking in debug builds and defined
wrapping behavior in release builds.

@item Data races
Prevented by Rust's Send and Sync traits. The type system ensures that
data cannot be accessed concurrently in unsafe ways.

@end table

@section Performance and compatibility

@command{rust-ed} achieves memory safety with minimal performance overhead:

@itemize @bullet
@item
Memory usage within 2x of GNU ed
@item
Execution time within 2x of GNU ed for typical operations
@item
100% command compatibility with GNU ed 1.22.2
@item
Identical exit codes and error messages
@item
Drop-in replacement capability
@end itemize

@section Testing methodology

@command{rust-ed} uses containerized differential testing to verify exact
compatibility with GNU ed 1.22.2. Both implementations run in identical
Docker containers with 119 automated test cases covering all 32 commands.


@node Limitations
@chapter Limitations

@command{rust-ed} maintains the same operational behavior as GNU ed with
some implementation differences:

If the terminal hangs up and the buffer is modified and not empty,
@command{rust-ed} attempts to write the buffer to the file @file{ed.hup} or,
if this fails, to @file{$HOME/ed.hup}.

If a text (non-binary) file is not terminated by a newline character, then
@command{rust-ed} appends one on reading/writing it. In the case of a binary
file, @command{rust-ed} does not append a newline on reading/writing.

The maximum line length is limited by available memory and the usize type
(typically 2^64-1 on 64-bit systems).

@command{rust-ed} uses Vec<String> internally for line storage, which
provides automatic memory management and bounds checking while maintaining
compatibility with GNU ed's behavior.


@node Diagnostics
@chapter Diagnostics

@command{rust-ed} prints two kinds of messages: diagnostic messages (errors
and warnings) written to standard error and help messages written to standard
output. Diagnostic messages may be suppressed with option @option{-q}. Help
messages may be enabled with option @option{-v} and may be toggled with
command @samp{H}.

@command{rust-ed} warns the first time that a command modifies a buffer
loaded from a read-only file.

When an error occurs, if @command{rust-ed}'s standard input is a regular file
or here document, then it exits, otherwise it prints a @samp{?} and returns
to command mode. An explanation of the last error can be printed with the
@samp{h} (help) command.

Error messages and behavior are identical to GNU ed 1.22.2 to maintain
perfect compatibility.


@node Problems
@chapter Reporting bugs

If you find a bug in @command{rust-ed}, please report it on GitHub:

@uref{https://github.com/attackordie/rust-ed/issues}

Include the version number, which you can find by running
@w{@samp{rust-ed --version}}.

When reporting bugs, please include:
@itemize @bullet
@item
The version of rust-ed (@samp{rust-ed --version})
@item
Your operating system and version
@item
Steps to reproduce the bug
@item
Expected behavior vs. actual behavior
@item
If reporting a compatibility issue with GNU ed, include the output from
both @command{rust-ed} and @command{ed}
@end itemize


@node GNU Free Documentation License
@chapter GNU Free Documentation License
@include fdl.texi

@bye
